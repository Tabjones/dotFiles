priority 10

extends c

snippet baseclass "(Class) ROS BaseNode Template"
/**\brief Class $1
 * {$0:Brief Description goes here!}
*/
class ${1:`!p snip.rv = snip.basename or "name"`}
{
public:
	/**\brief Constructor */
	${1/(\w+).*/$1/} (${2:arguments});

	/**\brief Destructor */
	virtual ~${1/(\w+).*/$1/} ();
	/**\brief Public Node Handle to be called from main() */
	${3:ros::NodeHandle nh;}
	$4

private:
	/**\brief Shared pointer to $5 Class */
	boost::shared_ptr<${5:Storage}> ${5/(\w+).*/\L$1\E/};

	/**\brief bool to control $6 module enable/disable */
	bool en_${6/(\w+).*/\L$1\E/};
	/**\brief Shared pointer of $6 module */
	boost::shared_ptr<${6:Module}> ${6/(\w+).*/\L$1\E/}_module;
	/**\brief Thread to control $6 module */
	boost::thread ${6/(\w+).*/\L$1\E/}_driver;
	/**\brief Worker thread for $6 module */
	void ${6/(\w+).*/\L$1\E/}_thread ();

	$7

	/**\brief Dynamic Reconfigure Server */
	dynamic_reconfigure::Server<${8:node::nodeConfig}> dyn_srv;
	/**\brief Callback for Dynamic Reconfigure
	 * Gets executed everytime the user changes a dynamic parameter
	 */
	void cb_${9:reconfigure} ($8 &config, uint32_t level);

	/**\brief Check Modules Method
	 * Evaluates booleans to enable or disable modules and spawns/kills relative threads
	 */
	void check_modules();
};
endsnippet

snippet moduleclass "(Class) ROS Module Template"
/**\brief Class $1
 * {$0:Brief Description goes here!}
*/
class ${1:`!p snip.rv = snip.basename or "name"`}
{
public:
	/**\brief Default constructor
	 * \param[in] $2 NodeHandle from base class
	 * \param[in] ${3/(\w+{,3}).*/\L$1\E/} Pointer to the $3 from base class 
	 */
	${1/(\w+).*/$1/}(ros::NodeHandle &${2:n}, boost::shared_ptr<${3:Storage}> &${3/(\w+{,3}).*/\L$1\E/});

	/**\brief Destructor */
	virtual ~${1/(\w+).*/$1/}(){ this->$5.shutdown(); }
	$4

private:
	/**\brief Shared pointer to $3 Class */
	boost::shared_ptr<$3> ${3/(\w+).*/\L$1\E/};

	/**\brief ROS NodeHandle to create a child namespace from Base Class nodehandle */
	ros::NodeHandle ${5:nh};
	/**\brief ROS CallbackQueue to handle custom callbacks */
	boost::shared_ptr<ros::CallbackQueue> ${6:queue_ptr};

	/**\brief Custom spin method	 */
	void spin_once(){ this->$6->callAvailable(ros::WallDuration(0)); }
};
endsnippet

snippet storageclass "(Class) ROS Storage Template"
/**\brief Class $1
 * {$0:Brief Description goes here!}
 */
class ${1:`!p snip.rv = snip.basename or "name"`}
{
public:
	/**\brief Empty constructor */
	${1/(\w+).*/$1/}();

/**\brief Destructor */
	virtual ~${1/(\w+).*/$1/}(){}

	/**\Brief Read $3 from class
	 * \param[in] ${3/(\w+{,3}).*/$1/} Pointer to $2 to fill with read data
	 * \return _True_ if operation was succesful, _False_ otherwise
	 */
	bool read_$3 (boost::shared_ptr<$2> &${3/(\w+{,3}).*/$1/});
	/**\brief Write $3 into class
	 * \param[in] ${3/(\w+{,3}).*/$1/} Pointer to $2 with data to store inside class
	 * \return _True_ if operation was succesful, _False_ otherwise
	 */
	bool write_$3 (boost::shared_ptr<$2> &${3/(\w+{,3}).*/$1/});

private:
	/**\brief Storaged $3 */
	${2:type} ${3:name};
	/**\brief Mutex to protect $3 */
	boost::mutex mtx_$3;
};
endsnippet

snippet storageaddrw "(Func) ROS add Read/Write methods to Storage class Template"
/**\brief Read $1 from class
 * \param[in] ${1/(\w+{,3}).*/$1/} Pointer to $2 to fill with read data
 * \return _True_ if operation was succesful, _False_ otherwise
 */
bool read_${1:name} (boost::shared_ptr<${2:type}> &${1/(\w+{,3}).*/$1/});
/**\brief Write $1 from class
 * \param[in] ${1/(\w+{,3}).*/$1/} Pointer to $2 with data to store inside class
 * \return _True_ if operation was succesful, _False_ otherwise
 */
bool write_$1 (boost::shared_ptr<$2> &${1/(\w+{,3}).*/$1/});
endsnippet

snippet storageadd "(Member) ROS add a new element to Storage class Template"
/**\brief Storaged $2 */
${1:type} ${2:name};
/**\brief Mutex to protect $2 */
boost::mutex mtx_$2;
endsnippet

snippet moduleadd2base "(Member) ROS add a Module to BaseNode class Template"
/**\brief bool to control ${1:mod} module enable/disable */
bool en_${1/(\w+).*/\L$1\E/};
/**\brief Shared pointer of $1 module */
boost::shared_ptr<$1> ${1/(\w+).*/\L$1\E/}_module;
/**\brief Thread to control $1 module */
boost::thread ${1/(\w+).*/\L$1\E/}_driver;
/**\brief Worker thread for $1 module */
void ${1/(\w+).*/\L$1\E/}_thread ();
endsnippet

snippet rosmain "ROS Main"
int main(int argc, char *argv[])
{
	ros::init(argc, argv, "${1:nodename}");
	${2:NodeClass} ${3:instance};
	//Try to go at $4hz
	ros::Rate rate(${4:50});
	while ($3.${5:nh}.ok())
	{
		ros::spinOnce();
		rate.sleep();
	}
	return 0;
}
endsnippet

snippet sleep "Boost sleep" b
//Sleep for $1 milliseconds
boost::this_thread::sleep(boost::posix_time::milliseconds(${1:100})); 
endsnippet

snippet ptr "Boost Shared pointer" b
boost::shared_ptr<${1:type}> ${2:name} ${3:(new $1)};
endsnippet

snippet pc "PCL Point Cloud" b
pcl::PointCloud<${1:pcl::PointXYZ}> ${2:name};
endsnippet

snippet pcptr "PCL Point Cloud Pointer" b
pcl::PointCloud<${1:pcl::PointXYZ}>::Ptr ${2:name} ${3:(new pcl::PointCloud<$1>)};
endsnippet

snippet pt "PCL Point Type"
pcl::PointXYZ
endsnippet

snippet ptn "PCL Point Normal Type"
pcl::PointNormal
endsnippet

snippet ptco "PCL Point Color Type"
pcl::PointXYZRGB
endsnippet

snippet cl "(Class) Generic"
/**\brief Class $3
 * {$0:Description goes here!}
 */
${1:template <typename $2>}
class ${3:`!p snip.rv = snip.basename or "name"`}
{
	public:
		/**\brief Empty constructor */
		${3/(\w+).*/$1/} ();
		/**\brief Destructor */
		virtual ~${3/(\w+).*/$1/} ();

	${4:protected:}

	${5:private:}

};//End of Class $3
endsnippet

#snippet fun "(Func) General function" b
#/**\brief ${0: Description}
# ${5:\param[in] ${3/[^ ]*}}
# */
#${1:return_value} ${2:func_name} (${3:func_arg1, ${4:func_arg2}});
#endsnippet
